import * as fs from "fs";
import * as path from "path";
import {Command} from "commander";

interface DataParsedCap {
    type: "start" | "end";
    name: string;
}

interface DataParsedContent {
    type: "value";
    value: string;
}

type DataParsed = DataParsedCap | DataParsedContent;

interface Card {
    name: string;
    content: string;
}

class CxxIncludeFile {
    public exactPath: string;
    public libPath: string;

    private parsedTrue: DataParsed[] = [];
    private cardsTrue: Card[] = [];

    private allLibFiles: string[] = [];

    constructor(exactPath: string, libPath: string) {
        this.exactPath = exactPath;
        this.libPath = libPath;

        if (!fs.existsSync(exactPath)) {
            throw new Error("File does not exist: " + exactPath);
        }

        if (!fs.lstatSync(exactPath).isFile()) {
            throw new Error("Not a file: " + exactPath);
        }

        if (!fs.existsSync(libPath)) {
            throw new Error("File does not exist: " + libPath);
        }

        if (!fs.lstatSync(libPath).isDirectory()) {
            throw new Error("Not a directory: " + libPath);
        }

        this.writeLibs();
        this.parse();
    }

    private writeLibs() {
        const allRecursiveFiles: string[] = [];

        const rec = (dir: string) => {
            const files = fs.readdirSync(dir);

            files.forEach((file) => {
                const fullPath = path.join(dir, file);

                if (fs.lstatSync(fullPath).isDirectory()) {
                    rec(fullPath);
                } else {
                    allRecursiveFiles.push(fullPath);
                }
            });
        };

        rec(this.libPath);
        this.allLibFiles = allRecursiveFiles;
    }

    private parse() {
        const lines = fs.readFileSync(this.exactPath, "utf8")
            .replace(/\r\n/g, "\n")
            .split("\n");

        let opened = false;
        let capture = "";

        lines.forEach((line) => {
            if (line.startsWith("// #Start")) {
                if (!opened) {
                    opened = true;

                    const name = line.substring(9).trim();
                    const data: DataParsed = {
                        type: "start",
                        name
                    };

                    this.parsedTrue.push(data);
                } else capture += line + "\n";
            } else if (line.startsWith("// #End")) {
                if (opened) {
                    opened = false;

                    const data: DataParsed = {
                        type: "end",
                        name: line.substring(7).trim()
                    };

                    this.parsedTrue.push(data);
                } else capture += line + "\n";
            } else {
                if (opened) {
                    const data: DataParsed = {
                        type: "value",
                        value: line
                    };

                    this.parsedTrue.push(data);
                }
            }
        });

        // now we need to simplify the data so that we can easily read it.
        let currentCard: Card | null = null;

        this.parsedTrue.forEach((data) => {
            if (data.type === "start") {
                if (currentCard) {
                    throw new Error("Unexpected start");
                }

                currentCard = {
                    name: data.name,
                    content: ""
                };
            } else if (data.type === "end") {
                if (!currentCard) {
                    throw new Error("Unexpected end");
                }

                if (data.name !== currentCard.name) {
                    throw new Error("Unexpected end");
                }

                this.cardsTrue.push(currentCard);
                currentCard = null;
            } else if (data.type === "value") {
                if (!currentCard) {
                    throw new Error("Unexpected value");
                }

                currentCard.content += data.value + "\n";
            }
        });
    }

    public get parsed() {
        return [ ...this.parsedTrue ];
    }

    public get cards() {
        return [ ...this.cardsTrue ];
    }

    public set cards(cards: Card[]) {
        this.cardsTrue = cards;
    }

    public get resultFile() {
        let result = "";

        this.cards.forEach((card) => {
            if (card.name === "Include") {
                result +=
                    "// ---                                                            --- //\n" +
                    "// --- The following guards for the includes must not be removed. --- //\n" +
                    "// --- The code bellow here will be auto generated by a script.   --- //\n" +
                    "// ---                                                            --- //\n\n";

                result += "// #StartInclude\n";

                this.libFiles
                    .filter(file => !file.endsWith(".cxx") && !file.endsWith(".c"))
                    .forEach((file) => {
                        result += `#include "../${file}"\n`;
                    });

                result += "// #EndInclude\n\n";
            } else {
                result += "// #Start " + card.name + "\n";
                result += card.content;
                result += "// #End " + card.name + "\n\n";
            }
        });

        return result + "// End of computer assisted include file.\n";
    }

    public get libFiles() {
        return [
            ...this.allLibFiles
                .map((file) => path.relative(process.cwd(), file))
        ];
    }
}

export function initGenerateIncludeCommand(program: Command) {
    program
        .command("generate-include")
        .description("Generate include file")
        .argument("<relative-path-to-include-file>", "Relative path to include file")
        .argument("<relative-path-to-cxx-lib-dir>", "Relative path to C++ library directory")
        .action((
            relativePathToIncludeFile: string,
            relativePathToCxxLibDir: string
        ) => {
            const pathTo = path.join(process.cwd(), relativePathToIncludeFile);
            const libTo = path.join(process.cwd(), relativePathToCxxLibDir);

            console.log("Generating include file: " + pathTo);

            const includeFile = new CxxIncludeFile(pathTo, libTo);

            fs.writeSync(fs.openSync(pathTo, "w"), includeFile.resultFile);

            console.log("Done");
        });
}
