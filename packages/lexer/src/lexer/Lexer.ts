import { Buffer } from "node:buffer";
import Token from "../token/Token";

/**
 * A lexer is a programmatic tool which analyzes a string, once finished, it can
 * manipulate the tokens, return them, and more.
 */
export default class Lexer<Structure extends Object> {
    /**
     * The input data of the lexer.
     */
    readonly input: string;

    /**
     * All the analyzed tokens from the lexical analyzer.
     */
    #tokens: Token<Structure>[] = [];

    /**
     * The new line character.
     */
    readonly newLine = "\n";

    /**
     * The token tree.
     */
    readonly tree: Structure;

    /**
     * Create a new lexical analyzer.
     *
     * @param tree The token regexp structure tree.
     * @param input The input data for the lexer.
     */
    public constructor(tree: Structure, input: string | Buffer) {
        this.input = input.toString();
        this.tree = tree;

        let badItem = false;

        Object.keys(tree).forEach(key => {
            badItem = badItem || !(tree as any)[key].source.startsWith("^");
        });

        if (badItem) {
            // TODO: Add a warning
        }

        this.#compileTokens();
    }

    /**
     * Run through with the lexer and generate a token list.
     */
    #compileTokens() {
        let operations = 0;

        let indexStat = 0;
        let lineStat = 0;
        let columnStat = 0;

        let indexPrev = 0;
        let linePrev = 0;
        let columnPrev = 0;

        const treeContainsNewLines = Object.values(this.tree).some(regexp => regexp.source.includes(this.#newLine));
        // Warn the user that this is unsafe
        if (treeContainsNewLines) {
            // TODO: Add a warning
            console.error("The lexer tree should contain new lines, this is unsafe and will cause issues.");
        }

        const perform = (input: string) => {
            operations++;

            let matchRegExpItem: keyof Structure | undefined;
            let passOverInput = input;
            let value = "";

            indexPrev = indexStat;
            linePrev = lineStat;
            columnPrev = columnStat;

            Object.keys(this.tree).forEach((key, index) => {
                if (matchRegExpItem) return;

                const regexp = new RegExp((this.tree as any)[key]);
                const match = regexp.exec(input);

                if (match) {
                    passOverInput = input.slice(match[0].length);
                    matchRegExpItem = key as any;
                    value = match[0];

                    columnStat += match[0].length;

                    if (match[0].includes(this.#newLine)) {
                        lineStat++;
                        columnStat = 0;
                    }

                    indexStat += match[0].length;
                }
            });

            if (typeof matchRegExpItem === "undefined") {
                console.error("Help!!");
                return; // TODO: throw error
            }

            const token: Token<Structure> = {
                lineStart: linePrev,
                lineEnd: lineStat,
                columnStart: columnPrev,
                columnEnd: columnStat,
                type: matchRegExpItem,
                end: indexStat,
                start: indexPrev,
                value,
            };

            this.#tokens.push(token);

            if (passOverInput.length !== input.length) {
                perform(passOverInput);
            }
        }

        perform(this.input);
    }

    /**
     * The tokens that were generated by the lexer.
     */
    public get tokens(): Token<Structure>[] {
        return this.#tokens;
    }
}
